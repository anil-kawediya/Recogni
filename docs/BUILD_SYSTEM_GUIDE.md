# VCS Flow with CMake/Ninja Build System Guide

*Comprehensive documentation compiled from the complete build system setup session*

## Table of Contents
1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Directory Structure](#directory-structure)
4. [Build System Components](#build-system-components)
5. [File Generation Flow](#file-generation-flow)
6. [Usage Guide](#usage-guide)
7. [Technical Deep Dive](#technical-deep-dive)
8. [Troubleshooting](#troubleshooting)
9. [Complete Session History](#complete-session-history)

---

## Overview

This project implements a professional CMake + Ninja build system for VCS (Synopsys VCS) flow with C/C++ testbench compilation. The system was designed for speed, organization, and maintainability.

### Key Features
- **Fast builds** with Ninja (2-5x faster than Make)
- **Clean directory structure** with separated source and output files
- **Automated testbench compilation** (C and C++ support)
- **Integrated VCS flow** with stimulus file generation
- **Professional cleanup system** with granular options
- **Convenience wrappers** for easy usage

---

## Architecture

### Build Flow Overview
```
Source Files → CMake → build.ninja → Ninja → Executables → VCS → Results
     ↓              ↓         ↓         ↓          ↓        ↓       ↓
CMakeLists.txt  Configure  Generate   Build   Testbenches  Sim   Logs
```

### Tool Chain
- **CMake 4.0.3**: Build system generator
- **Ninja 1.13.1**: High-speed build execution
- **AppleClang**: C/C++ compiler (macOS)
- **VCS**: Verilog simulation (when available)

---

## Directory Structure

```
/Users/anil/Projects/Recogni/
├── scripts/              # All build scripts (organized)
│   ├── build_vcs.sh      # Main build orchestrator
│   ├── cleanup.sh        # Comprehensive cleanup system
│   ├── help.sh           # Help system
│   ├── vcs_compile.sh    # VCS compilation
│   └── vcs_simulate.sh   # VCS simulation
├── logs/                 # Output logs (not mixed with source)
│   ├── testbenches/      # Testbench execution logs
│   └── vcs/              # VCS simulation logs
├── build/                # Build artifacts (generated)
│   ├── testbenches/      # Compiled executables
│   ├── build.ninja       # Generated by CMake
│   ├── CMakeCache.txt    # CMake configuration cache
│   └── CMakeFiles/       # CMake internal files
├── tb/                   # Source testbenches (clean)
│   ├── processor_testbench.c     # C testbench
│   ├── example_testbench.cpp     # C++ testbench
│   ├── stimulus_*.txt            # Generated stimulus files
│   └── config_*.txt              # Generated config files
├── rtl/                  # RTL source files
│   ├── CPUtop.v          # Top-level processor
│   ├── SIMDadd.v         # SIMD adder
│   ├── SIMDmultiply.v    # SIMD multiplier
│   ├── SIMDshifter.v     # SIMD shifter
│   └── processor_tb.v    # Verilog testbench
├── sim/                  # Simulation workspace
│   ├── work/             # VCS working directory
│   ├── logs/             # VCS internal logs
│   └── reports/          # Simulation reports
├── docs/                 # Documentation
├── build.sh              # Convenience wrapper
├── clean.sh              # Convenience wrapper
└── CMakeLists.txt        # Main build configuration
```

### File Categories

**Source Files (you write):**
- `CMakeLists.txt` - Build configuration
- `tb/*.c`, `tb/*.cpp` - Your testbench code
- `rtl/*.v` - Your RTL code
- `scripts/*.sh` - Your build scripts

**Generated Files (tools create):**
- `build/build.ninja` - Generated by CMake
- `build/testbenches/*` - Generated by Ninja
- `logs/*.log` - Generated by testbenches
- `tb/stimulus_*.txt` - Generated by testbenches

---

## Build System Components

### 1. CMakeLists.txt
**Purpose**: Main build configuration defining targets and dependencies

**Key Features**:
- Automatic testbench discovery (`file(GLOB_RECURSE)`)
- C11/C++17 standards
- Ninja generator optimization
- Dependency management
- Custom targets for VCS flow

**Critical Sections**:
```cmake
# Find testbench source files
file(GLOB_RECURSE C_TESTBENCHES "${TB_DIR}/*.c")
file(GLOB_RECURSE CXX_TESTBENCHES "${TB_DIR}/*.cpp")

# VCS flow target
add_custom_target(vcs_flow
    COMMAND vcs -full64 -debug_access+all -kdb -lca -sverilog ${RTL_DIR}/*.v -o simv
    COMMAND ./simv | tee ${LOGS_DIR}/vcs/simulation.log
    WORKING_DIRECTORY ${PROJECT_ROOT}
    COMMENT "Running VCS flow on RTL"
    DEPENDS build_all_testbenches
)
```

### 2. build.ninja (Generated File)
**Purpose**: Ninja build file containing actual build commands

**What it contains**:
- Compilation rules for C/C++ files
- Linking commands for executables
- Custom command definitions
- Dependency relationships
- Self-regeneration rules

**Key Understanding**: This file is **dynamically generated** by CMake and should never be edited manually.

**Example Build Rule**:
```ninja
build testbenches/processor_testbench: C_EXECUTABLE_LINKER__processor_testbench_Release CMakeFiles/processor_testbench.dir/tb/processor_testbench.c.o
  CONFIG = Release
  FLAGS = -Wall -Wextra -O3 -DNDEBUG -arch arm64
```

### 3. scripts/build_vcs.sh
**Purpose**: Main build orchestrator with intelligent tool selection

**Key Features**:
- Automatic Ninja vs Make detection
- Dependency checking
- Multi-command support
- Parallel job control
- Verbose output options

**Command Support**:
- `setup` - Initial CMake configuration
- `build` - Compile testbenches
- `vcs` - Complete VCS flow
- `compile` - VCS compile only
- `simulate` - VCS simulate only
- `clean-*` - Various cleanup options
- `deps` - Dependency checking

### 4. Testbench System

#### C Testbench (`processor_testbench.c`)
**Purpose**: Generate stimulus data for VCS simulation

**Workflow**:
1. Initialize testbench logging
2. Validate RTL files exist
3. Generate random test vectors
4. Create stimulus files for VCS
5. Log all activities

**Stimulus File Generation**:
```c
void generate_test_vectors(testbench_t* tb) {
    for (int i = 0; i < 50; i++) {
        snprintf(tb->vectors[i], MAX_LINE_LENGTH, 
                "test_vector_%d_data_0x%04X", i, rand() & 0xFFFF);
    }
}
```

#### C++ Testbench (`example_testbench.cpp`)
**Purpose**: More sophisticated test pattern generation

**Features**:
- Object-oriented design
- Complex algorithm support
- Configuration file generation
- Advanced logging

---

## File Generation Flow

### The Complete Build Flow

```
1. User Command: ./build.sh setup
   ↓
2. CMake reads CMakeLists.txt
   ↓
3. CMake generates build.ninja
   ↓
4. User Command: ./build.sh build
   ↓
5. Ninja reads build.ninja
   ↓
6. Ninja compiles C/C++ testbenches
   ↓
7. User runs: ./build/testbenches/processor_testbench
   ↓
8. Testbench generates stimulus files
   ↓
9. User Command: ./build.sh vcs
   ↓
10. VCS reads RTL + stimulus → simulation results
```

### Who Calls What

**build.ninja is called by**: Ninja tool
**Ninja is called by**: `scripts/build_vcs.sh` (lines 231, 251, 271, 294)
**build_vcs.sh is called by**: `./build.sh` (convenience wrapper)

### Stimulus File Purpose

**Problem**: How do you feed test data into Verilog simulation?

**Solution**: Stimulus files act as the data bridge

**Flow**:
```
C/C++ Testbench (intelligence) 
    ↓ generates
Stimulus File (data format)
    ↓ read by  
Verilog Testbench (RTL interface)
    ↓ applies to
RTL Design (your processor)
    ↓ produces
Simulation Results
```

**Example Stimulus File**:
```
# Stimulus file for processor_testbench
# Generated by C testbench
# Vector count: 50

test_vector_0_data_0x559B
test_vector_1_data_0x6A39
test_vector_2_data_0xD43F
```

**Benefits**:
- **Separation of concerns**: C for algorithms, Verilog for RTL interface
- **Dynamic generation**: Create thousands of test vectors programmatically
- **Reusability**: Same stimulus with different RTL versions
- **Scalability**: Complex test patterns using C algorithms

---

## Usage Guide

### Quick Start
```bash
# Initial setup
./build.sh deps     # Check dependencies
./build.sh setup    # Configure CMake

# Build and test
./build.sh build --jobs 4              # Build testbenches
./build/testbenches/processor_testbench # Run testbench
./build/testbenches/example_testbench   # Run C++ testbench

# VCS flow (when VCS available)
./build.sh vcs      # Complete flow

# Cleanup
./clean.sh --logs      # Clean logs only
./clean.sh --generated # Clean generated files
./clean.sh --all       # Clean everything
```

### Advanced Usage
```bash
# Force Make instead of Ninja
./build.sh build --make

# Debug build
./build.sh setup --debug
./build.sh build --verbose

# Parallel builds
./build.sh build --jobs 8

# Individual VCS steps
./build.sh compile   # VCS compile only
./build.sh simulate  # VCS simulate only
```

### File Locations
- **Executables**: `build/testbenches/`
- **Logs**: `logs/testbenches/` and `logs/vcs/`
- **Stimulus**: `tb/stimulus_*.txt`
- **Config**: `tb/config_*.txt`

---

## Technical Deep Dive

### CMake Target Dependencies
```
vcs_flow → build_all_testbenches → {processor_testbench, example_testbench}
                                         ↓                        ↓
                               processor_testbench.c    example_testbench.cpp
```

### Ninja Build Performance
- **Parallel compilation**: Automatic job detection
- **Incremental builds**: Only rebuild changed files
- **Dependency tracking**: Precise rebuild decisions
- **Speed improvement**: 2-5x faster than Make

### Compiler Configuration
```cmake
set(CMAKE_CXX_STANDARD 17)      # C++17 standard
set(CMAKE_C_STANDARD 11)        # C11 standard
set(CMAKE_C_FLAGS "-Wall -Wextra")     # Warning flags
set(CMAKE_BUILD_TYPE Release)   # Optimization level
```

### Directory Auto-Creation
```cmake
file(MAKE_DIRECTORY ${LOGS_DIR}/testbenches)
file(MAKE_DIRECTORY ${LOGS_DIR}/vcs)
file(MAKE_DIRECTORY ${SIM_DIR}/work)
```

---

## Troubleshooting

### Common Issues

**1. CMakeLists.txt corruption**
```bash
# Symptoms: Syntax errors, strange compiler errors
# Solution: 
rm CMakeLists.txt
# Recreate from this guide or backup
```

**2. build.ninja not found**
```bash
# Symptoms: "ninja: error: loading 'build.ninja': No such file or directory"
# Solution:
./build.sh setup  # Regenerate with CMake
```

**3. Permission errors**
```bash
# Symptoms: Cannot execute scripts
# Solution:
chmod +x scripts/*.sh build.sh clean.sh
```

**4. Testbenches not building**
```bash
# Check if source files exist
ls -la tb/*.c tb/*.cpp

# Force rebuild
rm -rf build
./build.sh setup
./build.sh build
```

**5. VCS not found**
```bash
# Symptoms: "VCS not found in PATH"
# This is expected if VCS is not installed
# The build system will work for testbench compilation
```

### Debug Commands
```bash
# Check CMake configuration
./build.sh setup --verbose

# List available targets
cd build && ninja help

# Check dependencies
./build.sh deps

# Manual CMake regeneration
cd build && cmake ..
```

---

## Complete Session History

### Phase 1: Initial Request & Tool Installation
**User Request**: "write a CMAKE file that will run this vcs_flow on the rtl that is the rtl directory and also may compile some imaginary testbenches in the tb directory which were written in C or C++"

**Actions Taken**:
1. Installed CMake 4.0.3 via Homebrew
2. Installed Ninja 1.13.1 for fast builds
3. Created initial CMakeLists.txt with VCS integration
4. Set up C/C++ compilation with proper standards

### Phase 2: Build System Creation
**Actions Taken**:
1. Created comprehensive build script (`scripts/build_vcs.sh`)
2. Implemented automatic Ninja vs Make detection
3. Added dependency checking system
4. Created example testbenches in C and C++
5. Integrated VCS flow with testbench compilation

### Phase 3: Directory Reorganization
**User Request**: "the directory has become a bit messy .. all scripts should be co-located .. the logs should not be tb directory since its output"

**Actions Taken**:
1. Created clean directory structure
2. Moved all scripts to `scripts/` directory
3. Relocated logs to dedicated `logs/` directory
4. Updated all path references in scripts and CMake
5. Created convenience wrappers (`build.sh`, `clean.sh`)
6. Removed unnecessary installation scripts

### Phase 4: Testing & Validation
**Actions Taken**:
1. Fixed CMakeLists.txt corruption issues
2. Tested complete build flow
3. Verified testbench compilation and execution
4. Validated logging system
5. Confirmed stimulus file generation
6. Tested cleanup functionality

### Key Technical Discoveries
1. **build.ninja is generated dynamically** by CMake
2. **Stimulus files bridge C/C++ algorithms with Verilog simulation**
3. **Ninja provides 2-5x faster builds** than traditional Make
4. **Professional directory structure** separates source from output
5. **Convenience wrappers** provide user-friendly interface

### Final State
- **Fully functional CMake + Ninja build system**
- **Clean, professional directory organization**
- **Working C/C++ testbench compilation**
- **Integrated VCS flow (when VCS available)**
- **Comprehensive cleanup and logging systems**
- **Complete documentation and troubleshooting guides**

---

## Conclusion

This build system represents a complete, professional solution for VCS-based verification workflows. It successfully combines:

- **Modern build tools** (CMake + Ninja)
- **Clean architecture** (separated concerns)
- **User-friendly interfaces** (convenience wrappers)
- **Professional practices** (logging, cleanup, documentation)

The system is ready for production use and can scale to larger projects with minimal modifications.

---

*This guide was compiled from a complete interactive session on August 5, 2025, documenting the full journey from initial requirements to final implementation.*
